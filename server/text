-- =========================================
-- SAFE Cart Schema Fix - Handle Existing Tables
-- =========================================
-- This approach safely updates existing tables instead of dropping them

-- Step 1: Check if we need to change user_id type in carts table
-- First, let's see the current structure
select column_name, data_type, is_nullable
from information_schema.columns 
where table_name = 'carts' and table_schema = 'public';

-- Step 2: If user_id is still uuid, we need to change it
-- (This will only run if the column is uuid)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'carts' 
        AND table_schema = 'public' 
        AND column_name = 'user_id' 
        AND data_type = 'uuid'
    ) THEN
        -- Add a temporary column
        ALTER TABLE public.carts ADD COLUMN user_id_new integer;
        
        -- Copy data (this will fail if there's existing data, but that's ok)
        -- UPDATE public.carts SET user_id_new = user_id::text::integer;
        
        -- Drop the old column and rename the new one
        ALTER TABLE public.carts DROP COLUMN user_id;
        ALTER TABLE public.carts RENAME COLUMN user_id_new TO user_id;
        
        -- Make it NOT NULL
        ALTER TABLE public.carts ALTER COLUMN user_id SET NOT NULL;
    END IF;
END $$;

-- Step 3: Ensure we have the right indexes
create index if not exists idx_carts_user on public.carts (user_id);
create index if not exists idx_cart_items_cart on public.cart_items (cart_id);

-- Step 4: One active cart per user (partial unique index)
drop index if exists uniq_active_cart_per_user;
create unique index if not exists uniq_active_cart_per_user
on public.carts (user_id)
where status = 'active';

-- Step 5: Updated_at triggers
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists carts_set_updated_at on public.carts;
create trigger carts_set_updated_at
before update on public.carts
for each row execute function public.set_updated_at();

drop trigger if exists cart_items_set_updated_at on public.cart_items;
create trigger cart_items_set_updated_at
before update on public.cart_items
for each row execute function public.set_updated_at();

-- Step 6: RLS Policies
alter table public.carts enable row level security;
alter table public.cart_items enable row level security;

-- Drop existing policies
drop policy if exists "own carts" on public.carts;
drop policy if exists "own cart items" on public.cart_items;
drop policy if exists "Allow all cart operations" on public.carts;
drop policy if exists "Allow all cart item operations" on public.cart_items;

-- Create new policies
create policy "Allow all cart operations"
on public.carts
for all
to public
using (true)
with check (true);

create policy "Allow all cart item operations"
on public.cart_items
for all
to public
using (true)
with check (true);

-- Step 7: Helper function (updated for integer user_id)
create or replace function public.get_or_create_active_cart(user_id_param integer)
returns public.carts
language plpgsql
security definer
as $$
declare
  v_cart public.carts;
begin
  select * into v_cart
  from public.carts
  where user_id = user_id_param and status = 'active'
  limit 1;

  if v_cart.id is null then
    insert into public.carts (user_id, status)
    values (user_id_param, 'active')
    returning * into v_cart;
  end if;

  return v_cart;
end;
$$;

-- Grant execute permission
revoke all on function public.get_or_create_active_cart(integer) from public;
grant execute on function public.get_or_create_active_cart(integer) to public;

-- Step 8: Verify the structure
select 
  table_name,
  column_name,
  data_type,
  is_nullable
from information_schema.columns 
where table_name in ('carts', 'cart_items') 
and table_schema = 'public'
order by table_name, ordinal_position;