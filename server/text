-- =========================================
-- SAFE Cart Schema Fix - Handle Existing Tables
-- =========================================
-- This approach safely updates existing tables instead of dropping them

-- Step 1: Check if we need to change user_id type in carts table
-- First, let's see the current structure
select column_name, data_type, is_nullable
from information_schema.columns 
where table_name = 'carts' and table_schema = 'public';

-- Step 2: If user_id is still uuid, we need to change it
-- (This will only run if the column is uuid)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'carts' 
        AND table_schema = 'public' 
        AND column_name = 'user_id' 
        AND data_type = 'uuid'
    ) THEN
        -- Add a temporary column
        ALTER TABLE public.carts ADD COLUMN user_id_new integer;
        
        -- Copy data (this will fail if there's existing data, but that's ok)
        -- UPDATE public.carts SET user_id_new = user_id::text::integer;
        
        -- Drop the old column and rename the new one
        ALTER TABLE public.carts DROP COLUMN user_id;
        ALTER TABLE public.carts RENAME COLUMN user_id_new TO user_id;
        
        -- Make it NOT NULL
        ALTER TABLE public.carts ALTER COLUMN user_id SET NOT NULL;
    END IF;
END $$;

-- Step 3: Ensure we have the right indexes
create index if not exists idx_carts_user on public.carts (user_id);
create index if not exists idx_cart_items_cart on public.cart_items (cart_id);

-- Step 4: One active cart per user (partial unique index)
drop index if exists uniq_active_cart_per_user;
create unique index if not exists uniq_active_cart_per_user
on public.carts (user_id)
where status = 'active';

-- Step 5: Updated_at triggers
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists carts_set_updated_at on public.carts;
create trigger carts_set_updated_at
before update on public.carts
for each row execute function public.set_updated_at();

drop trigger if exists cart_items_set_updated_at on public.cart_items;
create trigger cart_items_set_updated_at
before update on public.cart_items
for each row execute function public.set_updated_at();

-- Step 6: RLS Policies
alter table public.carts enable row level security;
alter table public.cart_items enable row level security;

-- Drop existing policies
drop policy if exists "own carts" on public.carts;
drop policy if exists "own cart items" on public.cart_items;
drop policy if exists "Allow all cart operations" on public.carts;
drop policy if exists "Allow all cart item operations" on public.cart_items;

-- Create new policies
create policy "Allow all cart operations"
on public.carts
for all
to public
using (true)
with check (true);

create policy "Allow all cart item operations"
on public.cart_items
for all
to public
using (true)
with check (true);

-- Step 7: Helper function (updated for integer user_id)
create or replace function public.get_or_create_active_cart(user_id_param integer)
returns public.carts
language plpgsql
security definer
as $$
declare
  v_cart public.carts;
begin
  select * into v_cart
  from public.carts
  where user_id = user_id_param and status = 'active'
  limit 1;

  if v_cart.id is null then
    insert into public.carts (user_id, status)
    values (user_id_param, 'active')
    returning * into v_cart;
  end if;

  return v_cart;
end;
$$;

-- Grant execute permission
revoke all on function public.get_or_create_active_cart(integer) from public;
grant execute on function public.get_or_create_active_cart(integer) to public;

-- Step 8: Verify the structure
select 
  table_name,
  column_name,
  data_type,
  is_nullable
from information_schema.columns 
where table_name in ('carts', 'cart_items') 
and table_schema = 'public'
order by table_name, ordinal_position;


-- Create orders table
CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    address TEXT NOT NULL,
    city VARCHAR(100) NOT NULL,
    postal_code VARCHAR(20) NOT NULL,
    notes TEXT,
    payment_method VARCHAR(50) NOT NULL DEFAULT 'cash_on_delivery',
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create order_items table with correct data types
CREATE TABLE IF NOT EXISTS order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,  -- Changed to UUID
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price DECIMAL(10,2) NOT NULL CHECK (price >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at);
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product_id ON order_items(product_id);

-- Create function to generate order number
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT AS $$
DECLARE
    new_number TEXT;
    counter INTEGER;
BEGIN
    new_number := TO_CHAR(NOW(), 'YYYYMMDD');
    SELECT COUNT(*) + 1 INTO counter 
    FROM orders 
    WHERE DATE(created_at) = CURRENT_DATE;
    new_number := 'ORD-' || new_number || '-' || LPAD(counter::TEXT, 3, '0');
    RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically set order_number
CREATE OR REPLACE FUNCTION set_order_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.order_number IS NULL OR NEW.order_number = '' THEN
        NEW.order_number := generate_order_number();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_order_number
    BEFORE INSERT ON orders
    FOR EACH ROW
    EXECUTE FUNCTION set_order_number();

-- Create trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_orders_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Grant necessary permissions
GRANT ALL ON orders TO authenticated;
GRANT ALL ON order_items TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE orders_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE order_items_id_seq TO authenticated;


-- Create product_reviews table for storing customer ratings and reviews
CREATE TABLE IF NOT EXISTS product_reviews (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create index for faster queries
CREATE INDEX IF NOT EXISTS idx_product_reviews_product_id ON product_reviews(product_id);
CREATE INDEX IF NOT EXISTS idx_product_reviews_user_id ON product_reviews(user_id);
CREATE INDEX IF NOT EXISTS idx_product_reviews_order_id ON product_reviews(order_id);

-- Create a view for product review statistics
CREATE OR REPLACE VIEW product_review_stats AS
SELECT 
    product_id,
    COUNT(*) as total_reviews,
    AVG(rating) as average_rating,
    COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star_count,
    COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star_count,
    COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star_count,
    COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star_count,
    COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star_count
FROM product_reviews
GROUP BY product_id;

-- Enable Row Level Security
ALTER TABLE product_reviews ENABLE ROW LEVEL SECURITY;

-- Allow users to read all reviews
CREATE POLICY "Anyone can read reviews" ON product_reviews
    FOR SELECT USING (true);

-- Allow users to create reviews for their own orders
CREATE POLICY "Users can create reviews for their orders" ON product_reviews
    FOR INSERT WITH CHECK (true);

-- Allow users to update their own reviews  
CREATE POLICY "Users can update their own reviews" ON product_reviews
    FOR UPDATE USING (true);

-- Allow users to delete their own reviews
CREATE POLICY "Users can delete their own reviews" ON product_reviews
    FOR DELETE USING (true);
-- Add status column to product_reviews table
ALTER TABLE product_reviews 
ADD COLUMN status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected'));

-- Create index for better performance on status filtering
CREATE INDEX IF NOT EXISTS idx_product_reviews_status ON product_reviews(status);

-- Update existing reviews to be approved (since they're already visible)
UPDATE product_reviews SET status = 'approved' WHERE status = 'pending';

-- Update the product_review_stats view to only include approved reviews
CREATE OR REPLACE VIEW product_review_stats AS
SELECT 
    product_id,
    COUNT(*) as total_reviews,
    AVG(rating) as average_rating,
    COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star_count,
    COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star_count,
    COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star_count,
    COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star_count,
    COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star_count
FROM product_reviews
WHERE status = 'approved'
GROUP BY product_id;

-- 1) Audit logs table
create table if not exists public.audit_logs (
  id uuid primary key default gen_random_uuid(),
  user_email text not null,
  action text not null,
  category text not null check (category in ('Authentication','User Management','Inventory','Orders')),
  description text not null,
  ip_address text,
  user_agent text,
  success boolean not null default true,
  details jsonb,
  created_at timestamp with time zone not null default now()
);

-- Indexes to speed up filters/search
create index if not exists idx_audit_logs_created_at on public.audit_logs (created_at desc);
create index if not exists idx_audit_logs_category on public.audit_logs (category);
create index if not exists idx_audit_logs_user_email on public.audit_logs (user_email);
create index if not exists idx_audit_logs_success on public.audit_logs (success);

-- 2) Optional: if your orders/status values differ, adjust the server queries accordingly.

-- 3) Ensure RLS fits your needs (example: allow staff read, admin insert)
-- Enable RLS if you use it
-- alter table public.audit_logs enable row level security;
-- create policy \"staff_read_logs\" on public.audit_logs for select using (true);
-- create policy \"admin_insert_logs\" on public.audit_logs for insert with check (true);