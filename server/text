POST   /api/v1/auth/register      - Create new account
POST   /api/v1/auth/login         - Login user
GET    /api/v1/auth/profile       - Get user profile
PUT    /api/v1/auth/profile       - Update profile
POST   /api/v1/auth/change-password - Change password
POST   /api/v1/auth/logout        - Logout user
GET    /api/v1/auth/verify        - Verify token
GET    /api/v1/auth/health        - Health check
GET    /health                    - Server health
GET    /                          - API info









CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  date_of_birth DATE,
  gender VARCHAR(10) CHECK (gender IN ('male', 'female', 'other')),
  role VARCHAR(20) NOT NULL DEFAULT 'customer' CHECK (role IN ('admin', 'manager', 'staff', 'customer')),
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  email_notifications BOOLEAN DEFAULT true,
  sms_notifications BOOLEAN DEFAULT false,
  last_login TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE verification_codes (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    code VARCHAR(10) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Index for quick lookup by email (optional but recommended)
CREATE INDEX idx_verification_codes_email ON verification_codes(email);



CREATE TABLE addresses (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  recipient_name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  full_address TEXT NOT NULL,
  address_type VARCHAR(20) CHECK (address_type IN ('home', 'work', 'other')) DEFAULT 'home',
  is_default BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);


-- products
-- products table
create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  code text unique,
  category text not null,
  supplier text not null,
  description text,
  price numeric(12,2) not null check (price >= 0),
  quantity integer not null default 0 check (quantity >= 0),
  min_stock integer not null default 0 check (min_stock >= 0),
  status text generated always as (
    case
      when quantity <= 0 then 'Out of Stock'
      when quantity <= min_stock then 'Low Stock'
      else 'In Stock'
    end
  ) stored,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- product_images table (many images per product)
create table if not exists public.product_images (
  id uuid primary key default gen_random_uuid(),
  product_id uuid not null references public.products(id) on delete cascade,
  image_url text not null,
  storage_path text, -- optional: path in Supabase Storage for housekeeping
  is_primary boolean not null default false,
  sort_order integer not null default 0,
  created_at timestamptz not null default now()
);

-- helpful indexes
create index if not exists idx_products_category on public.products (category);
create index if not exists idx_products_supplier on public.products (supplier);
create index if not exists idx_products_status on public.products (status);
create index if not exists idx_product_images_product_id on public.product_images (product_id);

-- updated_at trigger
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists set_products_updated_at on public.products;
create trigger set_products_updated_at
before update on public.products
for each row execute function public.set_updated_at();

-- Ensure only one primary image per product (optional constraint via partial unique index)
drop index if exists uniq_primary_image_per_product;
create unique index uniq_primary_image_per_product
on public.product_images (product_id)
where is_primary = true;







==========================================
DATABASE QUERIES (Users Table)
==========================================
-- Check if user exists by email
SELECT * FROM users WHERE email = 'user@example.com' LIMIT 1;

-- Find user by email (case-insensitive)
SELECT * FROM users WHERE LOWER(email) = LOWER('user@example.com');

-- Create new user
INSERT INTO users (email, password_hash, first_name, last_name, phone, role, status, created_at, updated_at) 
VALUES ('user@example.com', '$2b$10$hashedpassword', 'John', 'Doe', '+1234567890', 'customer', 'active', NOW(), NOW());

-- Update user's last login
UPDATE users SET last_login = NOW() WHERE id = 1;

-- Get all users (ordered by ID)
SELECT * FROM users ORDER BY id;

-- Get user by ID
SELECT * FROM users WHERE id = 1;

-- Check if user account is active
SELECT * FROM users WHERE id = 1 AND status = 'active';

-- Update user profile
UPDATE users SET 
  first_name = 'New Name',
  last_name = 'New Last',
  phone = '+1234567890',
  updated_at = NOW()
WHERE id = 1;

-- Change user password
UPDATE users SET 
  password_hash = '$2b$10$newhashedpassword',
  updated_at = NOW()
WHERE id = 1;

-- Delete user (soft delete - set status to inactive)
UPDATE users SET status = 'inactive', updated_at = NOW() WHERE id = 1;

-- Get users by role
SELECT * FROM users WHERE role = 'admin';

-- Get active users only
SELECT * FROM users WHERE status = 'active';

-- Count total users
SELECT COUNT(*) as total_users FROM users;

-- Count users by role
SELECT role, COUNT(*) as count FROM users GROUP BY role;


